Summarized conversation historyI'll write a short todo list to track this explanation task and next implementation actions, then I'll provide the full A→Z implementation explanation in Arabic and actionable next steps. 

Created 7 todos

أبدأ بشرح ما طلبت — شرح تفصيلي من الألف إلى الياء لِـ "B2B Suggested establishments" بناءً على كل التعديلات والملفات اللي عملناها في المشروع، ثم أعلّق على النقاط المفتوحة، المشاكل اللي ظهرت أثناء البناء (build)، وخطة تنفيذ واضحة للخطوات التالية مع مرفقات عملية (أين أعمل التغييرات، ماذا أرسل للـ Infra/DB/UI/AI teams، وكيف أتحقق من الشغل محلياً).

## ما سأغطيه الآن
- نظرة عامة على الحل والهندسة المعمارية
- قائمة الملفات الأساسية والغرض منها (مصدر/مسار)
- تدفق الطلب من الواجهة إلى AI (خطوة بخطوة)
- نموذج البيانات (DTOs) والشكل النهائي للـ JSON
- طبقة الخدمة (قواعد العمل: عرض مرة واحدة فقط وتسجيل الإجراءات)
- طبقة الـ proxy (الاتصال بـ Apigee / OSB / AI) ومعالجة الأخطاء
- المخزن (JPA) وتخطيط الـ DB + السكربت
- قضايا البناء الحالية (لماذا فشل mvn وكيف نحلها)
- كيف تختبر محلياً (خطوات سريعة)
- حالات الحافة والاعتبارات الأمنية
- عناصر العمل التالية (من يحتاج يتدخل وماذا يفعل)
- ملاحظات ختامية وملخص سريع

## 1) نظرة عامة على الحل (Architecture)
الحل صُمم كخدمة في وحدة ownersphere داخل المشروع. الهدف: عند زيارة صفحة مؤسسة (establishment) في واجهة B2B تُعرض "Suggested Establishments" مقترحة من خدمة AI — لكن فقط مرة واحدة لكل تسجيل مؤسسة (regNo). إذا قام المستخدم بأي تفاعل (Followed, Partially Followed, Skipped, View) تُسجل الحالة وتُمنع الإظهار لاحقاً.

الخط الزمني للطلب:
1. UI يطلب اقتراحات لمؤسسة برقم تسجيل regNo عبر Apigee Proxy (UI → Apigee Proxy #1).
2. Apigee يمرر الطلب إلى خدمة OWS/ownersphere (REST API الجديد).
3. الخدمة تتحقق في قاعدة البيانات هل الاقتراحات ظهرت سابقاً لهذه المؤسسة:
   - إذا نُفِذت سابقاً: تُعيد [] (قائمة فارغة) أو علامة "لا عرض".
   - إذا لا: تستدعي Apigee (أو OSB عبر Apigee) الذي يتصل بالـ AI (متطلب infra).
4. تستقبل الخدمة استجابة AI (قائمة اقتراحات)، تُسجل أن الاقتراحات عُرضت (row في DB)، وتُعيد الاستجابة للـ UI.
5. عندما يتفاعل المستخدم (Follow/Skip/Connect) يتم POST لواجهة actions ليُسَجّل الإجراء ويُحدّث السجل.

ملاحظات:
- Outbound إلى AI يجب أن يمر عبر Apigee (تم تعديل الـ proxy لطلب Apigee URL).
- سياسة "عرض مرة واحدة" تُطبّق على مستوى registrationNumber، وليست per-user بالوقت الحالي (يمكن توسيع لاحقاً).

## 2) الملفات الأساسية التي تم إنشاؤها/تعديلها (مسارات + غرض)
(أدرج فقط الملفات المهمة لتنفيذ الميزة)

- API interface + impl (مطابقة لمعايير المشروع)
  - `osp-api/src/main/java/sa/gov/gosi/si/osp/api/b2b/B2BSuggestionsApi.java`
    - واجهة API (GET/POST endpoints): تعريف المسارات والـ DTOs على مستوى الـ API module.
  - `osp-api/src/main/java/sa/gov/gosi/si/osp/api/b2b/B2BSuggestionsApiImpl.java`
    - تطبيق الـ API، يحتوي على الترحيل إلى الطبقة الخدمية (`EstablishmentSuggestionsService`).
    - ملاحظة: `getCurrentPersonId()` حالياً placeholder ويجب ربطه بالسياق الأمني (JWT).

- DTOs (في وحدة ownersphere لكي تكون متاحة للخدمة والـ proxy)
  - `ownersphere/src/main/java/.../dto/SuggestionsResponse.java`
    - الحقل الرئيسي: `List<EstablishmentSuggestion> establishments` (مطابق للمواصفة).
  - `ownersphere/src/main/java/.../dto/EstablishmentSuggestion.java`
    - الحقول: `establishmentName`, `establishmentLocation`, `DateInfo startDate`, `Long unn`, `String registrationNumber`, `BilingualText suggestionReason`.
  - `ownersphere/src/main/java/.../dto/DateInfo.java`
    - الحقول: `entryFormat`, `gregorian`, `hijiri`.
  - `ownersphere/src/main/java/.../dto/SuggestionsActionRequest.java`
    - لالتقاط أفعال المستخدم (action enum/ string, followedCount) من UI.

- خدمة الأعمال (Service)
  - `ownersphere/src/main/java/.../service/EstablishmentSuggestionsService.java`
    - تحقق ما إذا عُرضت الاقتراحات مسبقاً، استدعاء proxy، تسجيل الحالة، وتحديث حالة الإجراء.

- الـ proxy (Outbound client)
  - `ownersphere/src/main/java/.../proxy/service/OsbAiProxy.java`
    - مسؤول عن استدعاء Apigee endpoint (يستخدم RestTemplate أو HttpClient).
    - يقرأ الـ base URL و apiKey من خصائص التطبيق (application.properties).
    - يتعامل مع استثناءات HTTP وtimeouts ويقوم بفallback إلى `empty` response (degrade gracefully).

- الكيان (JPA Entity) والمستودع
  - `ownersphere/src/main/java/.../domain/EstablishmentSuggestionsStatusEntity.java`
    - Fields: id (sequence), registrationNo (unique), suggestionsShown (Boolean), userAction (String), followedCount (Integer), firstShownDate (Timestamp), actionDate (Timestamp), personId (Long).
    - ورث `Auditable` ليتوافق مع بقية المشروع.
  - `ownersphere/src/main/java/.../repository/EstablishmentSuggestionsStatusRepository.java`
    - JpaRepository مع طرق بحث findByRegistrationNo(...) ومساعدة boolean wereSuggestionsShown(...).

- DB script
  - `owner-sphere-db-scripts/migration_scripts/create_suggestions_status_table.sql`
    - إنشاء SEQUENCE وTABLE مع constraints وindex وgrants.

- وثائق Apigee
  - `APIGEE_OSB_PROXY_SETUP.md` (شرح كيف تهيئ الـ proxy، KVM للمفاتيح، وإنشاء Developer App).

## 3) تدفق الطلب مفصّل (مثال GET)
1. UI -> GET /api/b2b/{regNo}/suggestions (تمرير regNo كـ path param).
2. `B2BSuggestionsApiImpl.getSuggestions(regNo)` يُستدعى.
   - يستخرج `personId` من السياق (حالياً return 1L placeholder).
   - ينادي `EstablishmentSuggestionsService.getAiSuggestions(regNo, personId)`.
3. `EstablishmentSuggestionsService.getAiSuggestions`
   - يستدعي repository: `wereSuggestionsShown(regNo)`:
     - إذا true => يعيد `SuggestionsResponse` مع empty `establishments`.
     - إذا false:
       - يدعو `OsbAiProxy.fetchAiSuggestions(regNo)`.
       - عند نجاح الاستدعاء: يسجل row جديد في `OSP_ESTABLISHMENT_SUGGESTIONS_STATUS` مع suggestionsShown=true, firstShownDate=now, personId=...، ثم يعيد الـ response كما هو.
       - عند فشل الاستدعاء (timeout أو 5xx): سجّل خطأ في اللوج، وأعد `SuggestionsResponse` مع empty `establishments` (graceful fallback).
4. UI يعرض الاقتراحات (إن وُجدت). عند أي تفاعل، UI ترسل POST إلى `/api/b2b/{regNo}/suggestions/action` مع body `SuggestionsActionRequest`.
5. `B2BSuggestionsApiImpl.recordAction` ينادي `service.recordUserAction(regNo, request)`.
   - الخدمة تحدث السجل (userAction, followedCount, actionDate) — بحيث بعد أي فعل تُعتبر العملية "مكتملة".

## 4) نموذج البيانات (JSON نهائي كما في المواصفة)
الاستجابة المتوقعة من الـ API (مطابقة حرفياً للمواصفة):

{
  "establishments": [
    {
      "establishmentName": "شركة مثال",
      "establishmentLocation": "الرياض",
      "startDate": {
        "entryFormat": "01/01/1440",
        "gregorian": "2019-09-11",
        "hijiri": "1440-01-01"
      },
      "unn": 123456789,
      "registrationNumber": "1234567890",
      "suggestionReason": {
        "arabic": "سبب بالعربية",
        "english": "reason in english"
      }
    },
    ...
  ]
}

ملاحظات: `suggestionReason` يستخدم كائن bilingual (`BilingualText` موجود في الـ common-library)؛ الحقول قد تُملأ من AI أو من منطق داخلي.

## 5) قواعد العمل الأساسية (Business rules)
- "Show once" rule:
  - بمجرد أن تُعرض الاقتراحات لأول مرة على أي مستخدم أو يتم أي تفاعل (Followed / Skipped / Viewed) تُسجّل السجل وتمنع الإظهار لاحقاً (per registrationNumber).
- أي فعل (Follow/Skip/View/Connect) يُعتبر إتماماً للعملية ويمنع إعادة العرض.
- إذا فشل استدعاء AI: الخدمة تعيد قائمة فارغة بدلاً من خطأ 5xx (degrade gracefully).
- سجل التتبع يحتفظ بـ personId (لتحليل لاحق)، firstShownDate و actionDate.
- (اقتراح مستقبلي) يمكن تغيير القاعدة لتكون per-user بدلاً من per-establishment إن طُلِب.

## 6) الـ Proxy (تفاصيل التنفيذ والمقاومات)
- `OsbAiProxy` يقوم باستدعاء Apigee URL مُكوّن من property `api.base.url` (مثلاً `https://apigee.company.local`).
- يضيف Header `x-api-key` من `app.apikey` أو تُمخزن في Apigee KVM (تبع infra).
- إعدادات timeout قابلة للتحديد عبر `osb.ai.timeout`.
- عند استجابة 200: يحول JSON إلى `SuggestionsResponse` DTO.
- عند HttpClientErrorException/HttpServerErrorException/ResourceAccessException: يلتقط الاستثناء، يسجل خطأ، ويُعيد `new SuggestionsResponse(Collections.emptyList())`.
- يجب أن يكون استدعاء الـ proxy قابل للاختبار (تقليد/mock) في الاختبارات.

## 7) JPA / DB + SQL Script
- الكيان `EstablishmentSuggestionsStatusEntity` يُخزن:
  - id (sequence `OSP_EST_SUGGESTIONS_SEQ`),
  - registration_no (unique),
  - suggestions_shown (boolean),
  - user_action (varchar),
  - followed_count (number),
  - first_shown_date (timestamp),
  - action_date (timestamp),
  - person_id (number).
- سجل SQL: `create_suggestions_status_table.sql` أنشأ sequence + table + index + grants. المساهمة التالية: تسليم الملف لـ DBA ليجري التنفيذ في dev/test/prod.
- بعد إنشاء الجدول تأكد من أن التطبيق لديه الصلاحية للـ insert/update/select.

## 8) قضايا البناء (Build) التي ظهرت وكيف نحلها
أثناء تنفيذ وتجميع المشروع ظهر خطأ أساسي في مرحلة الـ compile يخص ملفات QueryDSL المولّدة التي تشير إلى `javax.annotation.processing.Generated` مما أدى إلى فشل `mvn clean install`.

السبب: إصدار JDK/annotation API أو الاعتماديات (dependencies) لم تشمل `javax.annotation-api` أو لم يكن classpath الخاص annotation processor يحتوي النوع `Generated`. هذا شائع عندما تُولّد ملفات QueryDSL أو JPA Metamodel والتي تستخدم `javax.annotation.Generated`.

مقترحات الحل:
1. في `ownersphere/pom.xml` أو الـ parent pom أضف dependency لـ javax.annotation:
   - للمشاريع التي تستخدم Java 9+ قد تحتاج إلى:
     - `javax.annotation:javax.annotation-api:1.3.2` أو أحدث
     - أو `jakarta.annotation:jakarta.annotation-api:1.3.5` حسب النسخة المطلوبة
   - مثال (pom.xml):
     <dependency>
       <groupId>javax.annotation</groupId>
       <artifactId>javax.annotation-api</artifactId>
       <version>1.3.2</version>
     </dependency>
   - ثم شغّل `mvn clean compile -DskipTests` مجدداً.
2. إذا كان الـ build يستخدم Java 11+ وملفات الـ generated تستخدم `javax.annotation.processing.Generated` وفي حالات أخرى تتطلب تعديل plugin لطبق `-parameters` أو استخدام إصدار QueryDSL متوافق.
3. بديل: إعادة توليد الـ Q-classes باستخدام نسخة QueryDSL متوافقة أو تغيير الـ imports في الأصناف المولدة — لكن هذا أقل استحساناً لأنه يتطلب تعديل مولدات الكود.

أنا مُستعد الآن لإضافة هذا التغيير مباشرة إلى `ownersphere/pom.xml` وأقوم بتشغيل build فحص محلي لو سمحت تأكيد إنك تريد أني أطبق الحل (أضيف dependency وأشغّل mvn) — أستطيع تنفيذ خطوة واحدة الآن وأتحقق من نتيجة البناء. (ملاحظة: سأعدّل فقط pom الخاص بالموديول ownersphere إن ذلك يناسب تنظيم المشروع).

## 9) كيف تختبر العمل محلياً (خطوات عملية)
- متطلبات:
  - JDK (مطابق لمشروع، على الأغلب Java 11 أو 17 — تأكد من نسخة المشروع).
  - Maven.
  - قاعدة بيانات dev (يمكن استخدام Oracle local أو dockerized db) — أو إعداد ملف application-dev.properties لتأشير إلى قاعدة dev.
- خطوات تشغيل سريعة (محلي):
  - تأكد من تحديث الخصائص:
    - `application.properties` أو `application-dev.properties` يحتوي:
      - api.base.url=https://apigee.dev.example
      - app.apikey=xxxxx (يمكن وضع قيمة dummy أثناء الاختبار)
      - osb.ai.timeout=5000
  - إن كنت ستجرب فقط الخدمة دون الحاجة للـ AI، قم بعمل Mock للـ OsbAiProxy (باستخدام Mockito في اختبار الوحدة) ليُعيد sample SuggestionsResponse.
  - شغّل build:
    - mvn -pl ownersphere -am clean package -DskipTests
  - شغّل التطبيق (أو كتابة اختبار integration بسيط باستخدام SpringBootTest مع MockBean لـ OsbAiProxy).
  - اختبر endpoints عبر curl/Postman:
    - GET http://localhost:8080/api/b2b/123456/suggestions
    - POST http://localhost:8080/api/b2b/123456/suggestions/action  body: {"action":"FOLLOWED", "followedCount":1}

سأدرج أوامر PowerShell جاهزة إن رغبت.

## 10) حالات الحافة (Edge cases)
- regNo غير معروف/غير صالح: الخدمة يجب أن تُعيد 400 أو [] حسب سياق المواصفة؛ حالياً نعتمد على validation قبل الوصول للخدمة.
- اتصال AI بطيء أو فشل: نرجع [] ونسجل خطأ في اللوج؛ يجب التنبيه في الـ monitoring.
- قفزات concurrency: عدة طلبات لـ same regNo تقريباً في وقت متقارب قد تؤدي إلى race condition حيث يُطلب AI مرتين قبل أن يسجل DB أن الاقتراحات عُرضت. حلول:
  - استخدام قفل صف (DB lock) أو شرط upsert atomic (INSERT ... ON CONFLICT أو MERGE) بناءً على الـ DB.
  - أو تحقق مجدد بعد حصول النتيجة قبل إدخال السجل.
- تعدد المستخدمين vs per-user requirement: المواصفات الحالية per-establishment. إن أردنا per-user يجب تعديل الـ key لتكون (personId, registrationNo).
- تغيّر صيغة استجابة AI: يجب وجود طبقة معالجة لتحويل الاستجابة إلى `EstablishmentSuggestion` مع الحقول المطلوبة.

## 11) عناصر العمل التالية — من يحتاج ماذا
- Infra (Apigee admin):
  - إنشاء Proxy #1 (UI → OWS) وتوجيه endpoint الصحيح.
  - إنشاء Proxy #2 أو تعديل flow OWS → OSB → AI، إعداد KVM لـ apiKey.
  - إنشاء Developer App وAPI Product إن لزم.
- DBA:
  - تطبيق `create_suggestions_status_table.sql` في بيئات dev/test/prod والتحقق من الصلاحيات.
- Security team:
  - تأكيد اسم الـ claim في JWT الذي يحوي `personId` أو كيف نستخرجهواضح كيفية الوصول له من الـ SecurityContext. أحتاج قيمة الـ claim أو مثال عن الـ JWT payload.
- AI team / OSB:
  - تأكيد endpoint الذي يجب استدعاؤه (URL، method، headers، body) وحقل `suggestionReason` وتنسيق التواريخ، وأيضاً ما إذا كان علينا تمرير سياق إضافي (قطاع، نوع، history).
- Frontend/UI:
  - استلام نماذج JSON وأحداث (Follow, Skip, Connect) وواجهة المستخدم لـ "Show once" + أزرار Select All / Refresh / Skip.
- QA/Testing:
  - كتابة اختبارات وحدية لخدمة وproxy وintegration test mocking OsbAiProxy.

## 12) ملخص تنفيذ التغييرات التي قمت بها (ماذا تغير في الكود)
- أضفت واجهة API وImplementation مطابقين لمعايير المشروع.
- بنية DTOs تم وضعها في وحدة ownersphere لكي تكون متاحة للـ service والـ proxy.
- كتبت منطق الخدمة الذي يطبق "عرض مرة واحدة" ويستدعي proxy للـ AI.
- أنشأت proxy مع fallback عند فشل الاتصال.
- أنشأت Entity وRepository لتتبع حالة العرض وإجراءات المستخدم.
- أضفت SQL DDL لإنشاء الجدول sequence.
- وثقت متطلبات Apigee وكيفية الإعداد (ملف MD).

التحقق: بعد التعديلات حاولت تشغيل build وواجهت خطأ متعلق بالـ generated classes والـ javax.annotation.Generated — حاجة لإضافة dependency أو تهيئة الـ annotation processing classpath.

## 13) هل أطبق الآن إصلاح build تلقائياً؟
أقدر أطبق التعديل التالي الآن:
- أضيف dependency `javax.annotation:javax.annotation-api:1.3.2` إلى `ownersphere/pom.xml` (أو إلى parent pom إذا هذا مناسب).
- أشغّل `mvn -pl ownersphere -am clean compile -DskipTests` وأوافيك بالنتيجة (PASS/FAIL مع الأخطاء).

هذا سيحل غالباً مشكلة `cannot find symbol: Generated`. أريد تأكيد منك للمتابعة بتنفيذ هذه الخطوة الآن. إن وافقت أطبّق التغيير وأشغّل البناء، ثم أقدّم تقرير مبسّط: ما تمّ، والنتيجة (نجح/فشل) وما التالي.

---

ما تريده الآن:
- هل أضيف dependency المذكور إلى `ownersphere/pom.xml` وأشغّل build للتحقق من حل مشكلة الـ Generated؟ (أقترح نعم — لأن هذا يفتح الطريق لاختبارات إضافية والتحقق من تكامل الخدمة).
- أو هل تفضّل أن أصف بقية الخطوات تفصيلاً إضافياً (مثل تغييرات الـ pom، أمثلة curl جاهزة للـ UI، أو نصائح لتحسين race-condition) قبل أن أعدل الكود؟

أنتظر موافقتك لأكمل التعديل والعَدّ build.
